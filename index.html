<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ICC Elite Pro OBS Overlay - Performance Edition</title>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Roboto:wght@400;500;700;900&family=Roboto+Condensed:wght@700&display=swap" rel="stylesheet">
    
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }
        body, html { width: 100%; height: 100%; overflow: hidden; background: transparent; font-family: 'Roboto', sans-serif; }
        #app-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        #video-source { position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0; pointer-events: none; }
        #broadcast-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        
        #setup-screen { position: absolute; inset: 0; z-index: 50; background: rgba(5, 8, 28, 0.98); display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .input-field { background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.1); color: #fbbf24; font-size: 3rem; text-align: center; font-weight: 700; letter-spacing: 0.5rem; width: 320px; padding: 0.5rem; border-radius: 1rem; outline: none; transition: all 0.3s; font-family: 'Anton', sans-serif; margin-bottom: 1rem; }
        .select-field { background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2); padding: 10px; width: 320px; font-size: 1rem; margin-bottom: 2rem; border-radius: 5px; outline: none; }
        .select-field option { background: #000; color: white; }
        .start-btn { background: linear-gradient(135deg, #fbbf24 0%, #d97706 100%); color: #000; border: none; padding: 1rem 4rem; border-radius: 50px; font-size: 1.1rem; font-weight: 800; letter-spacing: 2px; cursor: pointer; box-shadow: 0 10px 30px rgba(251, 191, 36, 0.3); text-transform: uppercase; }
        #cam-status { position: absolute; top: 10px; right: 10px; font-size: 10px; color: rgba(255,255,255,0.3); font-family: monospace; z-index: 100; pointer-events: none; }
    </style>
</head>
<body>
    <audio id="audio-four" src="four.mp3" preload="auto"></audio>
    <audio id="audio-six" src="six.mp3" preload="auto"></audio>
    <audio id="audio-wicket" src="wicket.mp3" preload="auto"></audio>

    <div id="cam-status">CAM: INIT</div>

    <div id="setup-screen">
        <h1 style="font-family: 'Anton'; font-size: 3rem; color: white; margin-bottom: 0.5rem; letter-spacing: 2px;">OBS ENGINE</h1>
        <p style="color: #94a3b8; font-size: 0.8rem; font-weight: bold; margin-bottom: 0.5rem; text-transform: uppercase;">1. Enter Match Code</p>
        <input type="text" id="match-id" class="input-field" placeholder="0000" maxlength="4" inputmode="numeric">
        <p style="color: #94a3b8; font-size: 0.8rem; font-weight: bold; margin-bottom: 0.5rem; text-transform: uppercase;">2. Select Video Source</p>
        <select id="cam-select" class="select-field"><option value="">Loading Cameras...</option></select>
        <button onclick="startOverlay()" class="start-btn">GO LIVE</button>
    </div>

    <div id="app-container" style="display: none;">
        <video id="video-source" autoplay playsinline muted></video>
        <canvas id="broadcast-canvas"></canvas>
    </div>

    <script>
        const firebaseConfig = { apiKey: "AIzaSyBqcD59IAPpKqk98oDZkgzgkoVZ8b8LGgY", authDomain: "livecricketscoring-92087.firebaseapp.com", databaseURL: "https://livecricketscoring-92087-default-rtdb.firebaseio.com", projectId: "livecricketscoring-92087", storageBucket: "livecricketscoring-92087.firebasestorage.app", messagingSenderId: "522927197627", appId: "1:522927197627:web:f1df5db736cae96893089e" };
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        let match = { t1: "HOME", t2: "AWAY", score: 0, wickets: 0, overs: 0, balls: 0, striker: { name: "", runs: 0, balls: 0 }, nonStriker: { name: "", runs: 0, balls: 0 }, bowler: { name: "", wkts: 0, runs: 0, balls: 0 }, currentOver: [], target: 0, totalOvers: 20, matchStatus: "", winner: "", margin: "", pom: null, showDismissalCard: false, showSummaryOverlay: false };
        let team1Logo = null, team2Logo = null, t1CapImg = null, t2CapImg = null; 
        let lastActionId = null, animType = null, animTime = 0;
        
        // REPLAY VARIABLES
        let replayRecorder = null, replayChunks = [], replayHeader = null, replayVideo = null, replayBlobUrl = null;
        let hasCameraAccess = false, replayState = "LIVE", replayStartTime = 0, replayType = "", transitionStartTime = 0;
        let stuckSafetyTimer = null;
        
        const video = document.getElementById('video-source');
        let currentStream = null;
        let crickerrLogoImg = new Image(); crickerrLogoImg.src = 'crickerrlogo.png';
        const canvas = document.getElementById('broadcast-canvas');
        const ctx = canvas.getContext('2d');

        window.onload = function() { 
            const params = new URLSearchParams(window.location.search);
            if(params.has('id')) { document.getElementById('match-id').value = params.get('id'); }
            resizeCanvas(); window.addEventListener('resize', resizeCanvas); getCameras();
        };
        
        async function getCameras() {
            const select = document.getElementById('cam-select');
            select.innerHTML = '<option value="">Searching...</option>';
            try {
                await navigator.mediaDevices.getUserMedia({ video: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                select.innerHTML = '';
                if (videoDevices.length === 0) { select.innerHTML = '<option value="">No Camera Found</option>'; return; }
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Camera ${index + 1}`;
                    select.appendChild(option);
                });
            } catch (err) { select.innerHTML = '<option value="">Camera Access Denied</option>'; }
        }
        
        function resizeCanvas() { const dpr = window.devicePixelRatio || 1; canvas.width = window.innerWidth * dpr; canvas.height = window.innerHeight * dpr; ctx.scale(dpr, dpr); canvas.style.width = window.innerWidth + 'px'; canvas.style.height = window.innerHeight + 'px'; }
        
        function startOverlay() { 
            const id = document.getElementById('match-id').value; 
            const camId = document.getElementById('cam-select').value;
            if(!id) return alert("Please enter Match ID"); 
            attemptCameraStart(camId);
            try { ['audio-four','audio-six','audio-wicket'].forEach(id => document.getElementById(id).load()); } catch(e){}
            document.getElementById('setup-screen').style.display = 'none'; 
            document.getElementById('app-container').style.display = 'block'; 
            requestAnimationFrame(renderLoop); 
            listenToDB(id); 
        }

        async function attemptCameraStart(deviceId) {
            // OPTIMIZATION: Default to 720p for smoothness
            let constraints = { video: { width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
            if (deviceId) { constraints.video.deviceId = { exact: deviceId }; }
            try { await startCameraStream(constraints); } 
            catch(e) {
                console.log("720p failed, trying basic...");
                try { constraints.video.width = undefined; constraints.video.height = undefined; await startCameraStream(constraints); } 
                catch(e2) { document.getElementById('cam-status').innerText = "CAM: OFF (ERROR)"; hasCameraAccess = false; }
            }
        }

        async function startCameraStream(constraints) {
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            currentStream = stream;
            video.srcObject = stream;
            video.play();
            hasCameraAccess = true;
            document.getElementById('cam-status').innerText = "CAM: ON";
            startRollingReplayBuffer(stream);
        }

        function startRollingReplayBuffer(stream) {
            // OPTIMIZATION: Reduced bitrate to 2.5 Mbps to prevent wobble
            let options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 2500000 };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) options = { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 2500000 };
            
            try {
                replayRecorder = new MediaRecorder(stream, options);
                replayChunks = [];
                replayHeader = null; 
                replayRecorder.ondataavailable = (e) => {
                    if (e.data && e.data.size > 0) {
                        if (!replayHeader) replayHeader = e.data;
                        else replayChunks.push(e.data);
                        // OPTIMIZATION: Keep only ~8-10 seconds to save memory
                        if(replayChunks.length > 25) replayChunks.shift(); 
                    }
                };
                replayRecorder.start(400); 
            } catch (e) { hasCameraAccess = false; }
        }

        function triggerReplay(type) {
            if (replayState !== "LIVE") return; 
            replayType = type;

            if(stuckSafetyTimer) clearTimeout(stuckSafetyTimer);
            stuckSafetyTimer = setTimeout(() => { cleanupReplay(); }, 12000); // Failsafe

            if (!hasCameraAccess || !replayRecorder || !replayHeader || replayRecorder.state !== 'recording') {
                replayState = "TRANSITION_IN";
                transitionStartTime = Date.now();
                return;
            }

            try {
                replayRecorder.requestData(); 
                const fullBlob = [replayHeader, ...replayChunks];
                const blob = new Blob(fullBlob, { type: replayHeader.type });
                replayBlobUrl = URL.createObjectURL(blob);

                if(replayVideo) { replayVideo.remove(); }
                replayVideo = document.createElement('video');
                replayVideo.muted = true;
                replayVideo.src = replayBlobUrl;
                replayVideo.playbackRate = 0.6;
                replayVideo.style.display = "none"; 
                // OPTIMIZATION: Wait for video to be ready before transitioning
                replayVideo.oncanplay = () => {
                     replayVideo.play().then(() => {
                        replayState = "TRANSITION_IN";
                        transitionStartTime = Date.now();
                     }).catch(e => cleanupReplay());
                };
                replayVideo.onerror = () => cleanupReplay();
                document.body.appendChild(replayVideo);
                
            } catch (e) {
                replayState = "TRANSITION_IN";
                transitionStartTime = Date.now();
            }
        }

        function cleanupReplay() {
            if(stuckSafetyTimer) clearTimeout(stuckSafetyTimer);
            if(replayVideo) { replayVideo.pause(); replayVideo.remove(); replayVideo = null; }
            if(replayBlobUrl) { URL.revokeObjectURL(replayBlobUrl); replayBlobUrl = null; }
            if(hasCameraAccess && replayRecorder && replayRecorder.state !== 'inactive') {
                replayRecorder.stop();
                setTimeout(() => { replayChunks = []; replayHeader = null; try { replayRecorder.start(400); } catch(e){} }, 100);
            }
            replayState = "LIVE";
        }

        function listenToDB(id) { 
            db.collection("live_matches").doc(id).onSnapshot(doc => { 
                if(doc.exists) { 
                    const data = doc.data(); 
                    match = { ...match, ...data }; 
                    if(data.t1Logo && (!team1Logo || team1Logo.src !== data.t1Logo)) { team1Logo = new Image(); team1Logo.src = data.t1Logo; } 
                    if(data.t2Logo && (!team2Logo || team2Logo.src !== data.t2Logo)) { team2Logo = new Image(); team2Logo.src = data.t2Logo; } 
                    if(data.t1CaptainImg && (!t1CapImg || t1CapImg.src !== data.t1CaptainImg)) { t1CapImg = new Image(); t1CapImg.src = data.t1CaptainImg; }
                    if(data.t2CaptainImg && (!t2CapImg || t2CapImg.src !== data.t2CaptainImg)) { t2CapImg = new Image(); t2CapImg.src = data.t2CaptainImg; }

                    if (data.lastAction && data.lastAction.id !== lastActionId) { 
                        lastActionId = data.lastAction.id; 
                        triggerAudio(data.lastAction.type);
                        if(['4', '6', 'W'].includes(data.lastAction.type)) {
                            setTimeout(() => triggerReplay(data.lastAction.type), 5000); 
                        }
                    } 
                } 
            }); 
        }

        function triggerAudio(type) {
            triggerAnim(type);
            const audioId = type === '4' ? 'audio-four' : type === '6' ? 'audio-six' : type === 'W' ? 'audio-wicket' : null;
            if (audioId) { const audio = document.getElementById(audioId); audio.currentTime = 0; audio.play().catch(e => console.log("Audio play blocked")); }
        }
        function triggerAnim(type) { animType = type; animTime = Date.now(); }

        function renderLoop() { 
            const w = window.innerWidth; const h = window.innerHeight; 
            ctx.clearRect(0, 0, w, h); 
            
            if (replayState === "LIVE") {
                if (hasCameraAccess && video.readyState >= 2) drawVideoObject(video, w, h);
                drawLiveGraphics(w, h);
            } else if (replayState === "TRANSITION_IN") {
                if (hasCameraAccess && video.readyState >= 2) drawVideoObject(video, w, h);
                drawLiveGraphics(w, h);
                let finished = drawCoolStinger(w, h, "IN");
                if (finished) { replayState = "PLAYING"; replayStartTime = Date.now(); }
            } else if (replayState === "PLAYING") {
                if (replayVideo && replayVideo.readyState >= 2) drawVideoObject(replayVideo, w, h);
                else if (hasCameraAccess && video.readyState >= 2) drawVideoObject(video, w, h);
                drawReplayOverlay(w, h); 
                const elapsed = Date.now() - replayStartTime;
                if (elapsed > 6000) { replayState = "TRANSITION_OUT"; transitionStartTime = Date.now(); }
            } else if (replayState === "TRANSITION_OUT") {
                if (hasCameraAccess && video.readyState >= 2) drawVideoObject(video, w, h);
                drawLiveGraphics(w, h); 
                let finished = drawCoolStinger(w, h, "OUT");
                if (finished) { cleanupReplay(); }
            }
            requestAnimationFrame(renderLoop); 
        }

        function drawVideoObject(vidObj, w, h) {
            try {
                const vidRatio = vidObj.videoWidth / vidObj.videoHeight;
                const screenRatio = w / h;
                let drawW, drawH, drawX, drawY;
                if (screenRatio > vidRatio) { drawW = w; drawH = w / vidRatio; drawX = 0; drawY = (h - drawH) / 2; } 
                else { drawW = h * vidRatio; drawH = h; drawX = (w - drawW) / 2; drawY = 0; }
                ctx.drawImage(vidObj, drawX, drawY, drawW, drawH);
            } catch(e) {}
        }

        function drawLiveGraphics(w, h) {
             if (match.showDismissalCard === true && match.dismissalData) drawDismissalCard(ctx, w, h);
            else if (match.matchStatus === "COMPLETE" || match.showSummaryOverlay === true) drawProfessionalSummary(ctx, w, h);
            else { drawNewLayout(ctx, w, h); drawPopups(ctx, w, h); } 
        }

        function drawCoolStinger(w, h, direction) {
            const now = Date.now();
            const elapsed = now - transitionStartTime;
            const duration = 1200; 
            let p = elapsed / duration;
            if (p > 1) return true;
            const ease = p < 0.5 ? 4 * p * p * p : 1 - Math.pow(-2 * p + 2, 3) / 2;
            ctx.save();
            let coverAlpha = 0;
            if(p < 0.3) coverAlpha = p / 0.3; else if(p > 0.7) coverAlpha = (1 - p) / 0.3; else coverAlpha = 1;                     
            if (coverAlpha > 0) {
                ctx.fillStyle = `rgba(15, 23, 42, ${coverAlpha})`; ctx.fillRect(0,0,w,h);
                const offset = (ease * w * 1.5) - (w * 0.25);
                ctx.beginPath(); ctx.moveTo(offset, 0); ctx.lineTo(offset + (w*0.2), 0); ctx.lineTo(offset + (w*0.1), h); ctx.lineTo(offset - (w*0.1), h);
                ctx.fillStyle = "rgba(59, 130, 246, 0.6)"; ctx.fill();
                if (coverAlpha > 0.8 && crickerrLogoImg.complete && crickerrLogoImg.naturalHeight > 0) {
                    const ls = h * 0.4; const dW = ls; const dH = ls;
                    ctx.shadowColor = "white"; ctx.shadowBlur = 20; ctx.drawImage(crickerrLogoImg, (w-dW)/2, (h-dH)/2, dW, dH); ctx.shadowBlur = 0;
                }
            }
            ctx.restore(); return false;
        }

        function drawReplayOverlay(w, h) {
            let text = "", subText = "", color1 = "", color2 = "", shape = ""; let textOffset = 0; 
            if (replayType === '6') { text = "6"; subText = "MAXIMUM"; color1 = "#22c55e"; color2 = "#14532d"; shape = "HEX"; textOffset = 0.05; } 
            else if (replayType === '4') { text = "4"; subText = "BOUNDARY"; color1 = "#3b82f6"; color2 = "#172554"; shape = "CIRCLE"; textOffset = 0.05; } 
            else if (replayType === 'W') { text = "OUT"; subText = "WICKET"; color1 = "#ef4444"; color2 = "#7f1d1d"; shape = "BOX"; textOffset = 0.02; } 
            else { text = "R"; subText = "REPLAY"; color1 = "#f59e0b"; color2 = "#78350f"; shape = "CIRCLE"; textOffset = 0.05; }
            const now = Date.now(); const elapsed = now - replayStartTime; const animTime = Math.max(0, elapsed - 100);
            let progress = animTime / 600; let scale = getElasticScale(progress); if (progress >= 1) scale = 1 + (Math.sin(now / 400) * 0.02);
            const badgeSize = h * 0.16; const barH = h * 0.095; const bottomY = h - barH - (h * 0.03); const goldY = bottomY - (barH * 0.04) - 2; const posX = w * 0.09; const posY = goldY - (badgeSize / 1.7); 
            ctx.save(); ctx.translate(posX, posY); ctx.scale(scale, scale);
            ctx.save(); ctx.shadowColor = "rgba(0,0,0,0.7)"; ctx.shadowBlur = 20; ctx.shadowOffsetY = 10; ctx.fillStyle = "black"; drawBadgeShape(ctx, shape, badgeSize); ctx.fill(); ctx.restore();
            const grad = ctx.createLinearGradient(-badgeSize/2, -badgeSize/2, badgeSize/2, badgeSize/2); grad.addColorStop(0, color1); grad.addColorStop(1, color2); ctx.fillStyle = grad; drawBadgeShape(ctx, shape, badgeSize); ctx.fill();
            ctx.strokeStyle = "white"; ctx.lineWidth = 4; drawBadgeShape(ctx, shape, badgeSize); ctx.stroke();
            ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; const fontSize = text.length > 2 ? badgeSize * 0.45 : badgeSize * 0.85; ctx.font = `900 ${fontSize}px 'Anton', sans-serif`; ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 0; ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 3; ctx.fillText(text, 0, badgeSize * textOffset); ctx.shadowColor = "transparent";
            const subY = badgeSize * 0.65; const pillW = badgeSize * 1.3; const pillH = badgeSize * 0.22; ctx.fillStyle = "#0f172a"; drawRoundRect(ctx, -pillW/2, subY, pillW, pillH, 8); ctx.fill(); ctx.strokeStyle = "#fbbf24"; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = "#fbbf24"; ctx.font = `700 ${badgeSize * 0.16}px 'Roboto Condensed'`; ctx.fillText(subText, 0, subY + (pillH/2) + 1);
            ctx.fillStyle = "white"; ctx.font = `700 ${badgeSize * 0.14}px 'Roboto'`; ctx.shadowColor = "black"; ctx.shadowBlur = 4; ctx.fillText("ACTION REPLAY", 0, -badgeSize * 0.82); ctx.restore();
        }

        function formatTeamName(name) { if (!name) return "TEAM"; let formatted = name.toUpperCase(); formatted = formatted.replace(/\bCRICKET CLUB\b/g, "C.C").replace(/\bCRICKET\b/g, "C.C").replace(/\bCC\b/g, "C.C"); return formatted; }
        function formatPlayerName(fullName) { if (!fullName) return ""; const parts = fullName.trim().split(/\s+/); if (parts.length > 1) { return (parts[0] + " " + parts[1].charAt(0) + ".").toUpperCase(); } return parts[0].toUpperCase(); }
        function drawRoundRect(c, x, y, w, h, r) { if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2; c.beginPath(); c.moveTo(x + r, y); c.arcTo(x + w, y, x + w, y + h, r); c.arcTo(x + w, y + h, x, y + h, r); c.arcTo(x, y + h, x, y, r); c.arcTo(x, y, x + w, y, r); c.closePath(); }
        function drawLogo(c, name, img, x, y, s, isLeft) { c.save(); c.beginPath(); c.arc(x + s/2, y + s/2, s/2, 0, Math.PI*2); c.fillStyle = "white"; c.fill(); c.clip(); if(img) c.drawImage(img, x, y, s, s); else { c.fillStyle = "#334155"; c.fillRect(x, y, s, s); c.fillStyle = "white"; c.textAlign = "center"; c.textBaseline = "middle"; c.font = `bold ${s*0.5}px 'Roboto'`; c.fillText(name.substring(0,2), x+s/2, y+s/2); } c.restore(); }
        function fitText(c, text, x, y, maxWidth, initialFontSize, weight, fontFace) { let fontSize = initialFontSize; c.font = `${weight} ${fontSize}px '${fontFace}'`; let width = c.measureText(text).width; while (width > maxWidth && fontSize > (initialFontSize * 0.5)) { fontSize -= 2; c.font = `${weight} ${fontSize}px '${fontFace}'`; width = c.measureText(text).width; } c.fillText(text, x, y); }
        function drawBallSquare(c, b, x, y, size) { let txt = b.toString(); let bgColor = "#ffffff"; let txtColor = "#000000"; if (txt === '4') { bgColor = "#0ea5e9"; txtColor = "white"; } else if (txt === '6') { bgColor = "#22c55e"; txtColor = "white"; } else if (txt.includes('W') && !txt.includes('WD')) { bgColor = "#dc2626"; txtColor = "white"; } else if (txt === '0' || txt === '•') { txt = "•"; bgColor = "white"; txtColor = "black"; } else { bgColor = "white"; txtColor = "black"; } c.save(); c.fillStyle = bgColor; c.fillRect(x, y, size, size); if (txt === "•") { c.fillStyle = "black"; c.beginPath(); c.arc(x + size/2, y + size/2, size * 0.18, 0, Math.PI * 2); c.fill(); } else { c.fillStyle = txtColor; c.textAlign = "center"; c.textBaseline = "middle"; c.font = (txt.includes('+') || txt.length > 2) ? `900 ${size * 0.45}px 'Roboto Condensed'` : `900 ${size * 0.7}px 'Roboto Condensed'`; c.fillText(txt, x + size/2, y + size/2 + (size * 0.05)); } c.restore(); }
        function drawPopups(c, w, h) { if (!animType) return; const now = Date.now(); if (now - animTime > 3000) { animType = null; return; } c.save(); const startX = w * 0.05; const startY = h - (h * 0.13) - (h * 0.06); c.translate(startX, startY); const t = (now - animTime) / 300; const scale = t < 1 ? (Math.sin(t * Math.PI/2) * 1.1) : 1.0; c.scale(scale, scale); c.textAlign = "left"; c.textBaseline = "bottom"; const fontSize = h * 0.08; c.font = `400 ${fontSize}px 'Anton'`; if (animType === '4') { c.fillStyle = "#3b82f6"; c.fillText("FOUR RUNS", 0, 0); } else if (animType === '6') { c.fillStyle = "#22c55e"; c.fillText("SIX RUNS", 0, 0); } else if (animType === 'W') { c.fillStyle = "#ef4444"; c.fillText("WICKET", 0, 0); } c.restore(); }
        function drawBadgeShape(ctx, shape, size) { ctx.beginPath(); if (shape === 'HEX') drawPolygon(ctx, 0, 0, size * 0.75, 6); else if (shape === 'CIRCLE') ctx.arc(0, 0, size * 0.70, 0, Math.PI * 2); else if (shape === 'BOX') { const w = size * 0.8; const h = size * 0.5; const tilt = size * 0.1; ctx.moveTo(-w + tilt, -h); ctx.lineTo(w + tilt, -h); ctx.lineTo(w - tilt, h); ctx.lineTo(-w - tilt, h); ctx.closePath(); } }
        function drawPolygon(ctx, x, y, radius, sides) { if (sides < 3) return; const a = (Math.PI * 2) / sides; const rotateOffset = sides === 6 ? Math.PI / 2 : 0; ctx.moveTo(x + radius * Math.cos(rotateOffset), y + radius * Math.sin(rotateOffset)); for (let i = 1; i < sides; i++) { ctx.lineTo(x + radius * Math.cos(a * i + rotateOffset), y + radius * Math.sin(a * i + rotateOffset)); } ctx.closePath(); }
        function getElasticScale(t) { if (t <= 0) return 0; if (t >= 1) return 1; const p = 0.5; return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1; }
        
        function drawNewLayout(c, w, h) {
            const barH = h * 0.095; const marginX = w * 0.03; const bottomY = h - barH - (h * 0.03); const pillW = w - (marginX * 2); const pillX = marginX; const isChasing = (match.target && match.target > 0);
            c.fillStyle = "#fbbf24"; const goldH = barH * 0.04; const goldY = bottomY - goldH - 2; c.fillRect(pillX, goldY, pillW, goldH);
            c.save(); c.fillStyle = "#05081c"; c.shadowColor = "rgba(0,0,0,0.5)"; c.shadowBlur = 10; drawRoundRect(c, pillX, bottomY, pillW, barH, 16); c.fill(); c.clip(); c.restore();
            if (crickerrLogoImg.complete && crickerrLogoImg.naturalHeight !== 0) { const cLogoH = barH * 1.5; const aspectRatio = crickerrLogoImg.width / crickerrLogoImg.height; const cLogoW = cLogoH * aspectRatio; const cLogoX = (pillX + pillW) - cLogoW; const cLogoY = goldY - cLogoH - 4; c.save(); c.shadowColor = "rgba(0,0,0,0.5)"; c.shadowBlur = 8; c.shadowOffsetY = 4; c.drawImage(crickerrLogoImg, cLogoX, cLogoY, cLogoW, cLogoH); c.restore(); }
            let x1 = pillX; let x2 = pillX + (pillW * 0.19); let x3 = pillX + (pillW * 0.30); let x4 = pillX + (pillW * 0.58); let x5 = pillX + (pillW * 0.81); let xToWinStart = 0; let xToWinEnd = 0; let bowlStart = x4; let bowlEnd = x5;
            if (isChasing) { x2 = pillX + (pillW * 0.19); x3 = pillX + (pillW * 0.30); x4 = pillX + (pillW * 0.53); xToWinStart = x4; xToWinEnd = pillX + (pillW * 0.63); bowlStart = xToWinEnd; bowlEnd = pillX + (pillW * 0.81); x5 = bowlEnd; }
            const drawDiv = (x) => { c.beginPath(); c.moveTo(x, bottomY + 5); c.lineTo(x, bottomY + barH - 5); c.strokeStyle = "rgba(255,255,255,0.8)"; c.lineWidth = 1.5; c.stroke(); };
            drawDiv(x2); drawDiv(x3); drawDiv(x4); if(isChasing) { drawDiv(xToWinEnd); drawDiv(bowlEnd); } else { drawDiv(x5); }
            const xEnd = pillX + pillW; const logoS = barH * 0.7; const displayImg1 = (t1CapImg && t1CapImg.src) ? t1CapImg : team1Logo; const displayImg2 = (t2CapImg && t2CapImg.src) ? t2CapImg : team2Logo;
            drawLogo(c, match.t1, displayImg1, x1 + 15, bottomY + (barH - logoS)/2, logoS, true); c.fillStyle = "white"; c.textAlign = "left"; fitText(c, formatTeamName(match.t1), x1 + 25 + logoS, bottomY + barH * 0.45, (x2 - x1) - logoS - 35, barH * 0.35, '700', 'Roboto Condensed');
            if (isChasing) { c.fillStyle = "#fbbf24"; c.font = `900 ${barH * 0.25}px 'Roboto Condensed'`; c.fillText(`TARGET ${match.target}`, x1 + 25 + logoS, bottomY + barH * 0.75); } else { c.fillStyle = "#64748b"; c.font = `700 ${barH * 0.16}px 'Roboto'`; c.fillText("BATTING", x1 + 25 + logoS, bottomY + barH * 0.70); }
            const scoreCenter = x2 + (x3 - x2)/2; c.textAlign = "center"; c.fillStyle = "#fbbf24"; c.font = `900 ${barH * 0.55}px 'Anton'`; c.fillText(`${match.score}/${match.wickets}`, scoreCenter, bottomY + barH * 0.60); c.fillStyle = "white"; c.font = `700 ${barH * 0.18}px 'Apple SD Gothic Neo', 'Roboto'`; c.fillText(`OVERS ${match.overs}.${match.balls}`, scoreCenter, bottomY + barH * 0.85);
            c.beginPath(); c.moveTo(x3 + 10, bottomY + barH/2); c.lineTo(x4 - 10, bottomY + barH/2); c.strokeStyle = "rgba(255,255,255,0.4)"; c.lineWidth = 1; c.stroke(); const batPad = 20; c.beginPath(); c.moveTo(x3 + 15, bottomY + barH * 0.25); c.lineTo(x3 + 22, bottomY + barH * 0.30); c.lineTo(x3 + 15, bottomY + barH * 0.35); c.fillStyle = "#fbbf24"; c.fill(); c.textAlign = "left"; c.fillStyle = "white"; c.font = `500 ${barH * 0.28}px 'Apple SD Gothic Neo', 'Roboto Condensed'`; c.fillText(match.striker.name ? formatPlayerName(match.striker.name) : "STRIKER", x3 + 30, bottomY + barH * 0.38); c.textAlign = "right"; c.font = `900 ${barH * 0.35}px 'Roboto Condensed'`; c.fillText(match.striker.runs||0, x4 - batPad - 40, bottomY + barH * 0.40); c.font = `400 ${barH * 0.2}px 'Roboto'`; c.fillText(`(${match.striker.balls||0})`, x4 - batPad, bottomY + barH * 0.38); c.textAlign = "left"; c.fillStyle = "white"; c.font = `500 ${barH * 0.28}px 'Apple SD Gothic Neo', 'Roboto Condensed'`; c.fillText(match.nonStriker.name ? formatPlayerName(match.nonStriker.name) : "NON-STRIKER", x3 + 30, bottomY + barH * 0.88); c.textAlign = "right"; c.font = `900 ${barH * 0.35}px 'Roboto Condensed'`; c.fillText(match.nonStriker.runs||0, x4 - batPad - 40, bottomY + barH * 0.90); c.font = `400 ${barH * 0.2}px 'Roboto'`; c.fillText(`(${match.nonStriker.balls||0})`, x4 - batPad, bottomY + barH * 0.88);
            if (isChasing) { const boxW = xToWinEnd - xToWinStart; const runsNeeded = Math.max(0, match.target - match.score); const totalBalls = match.totalOvers * 6; const ballsBowled = (match.overs * 6) + match.balls; const ballsRem = Math.max(0, totalBalls - ballsBowled); const crr = ballsBowled > 0 ? (match.score / (ballsBowled/6)).toFixed(1) : "0.0"; const rrr = ballsRem > 0 ? (runsNeeded / (ballsRem/6)).toFixed(1) : "-"; c.save(); const winGrad = c.createLinearGradient(xToWinStart, bottomY, xToWinEnd, bottomY); winGrad.addColorStop(0, "#1565c0"); winGrad.addColorStop(1, "#0d47a1"); c.fillStyle = winGrad; c.fillRect(xToWinStart, bottomY, boxW, barH); const boxCenter = xToWinStart + boxW/2; c.textAlign = "center"; c.fillStyle = "#dbeafe"; c.font = `700 ${barH * 0.16}px 'Roboto Condensed'`; c.fillText("TO WIN", boxCenter, bottomY + barH * 0.20); c.fillStyle = "white"; c.font = `900 ${barH * 0.52}px 'Anton'`; c.fillText(`${runsNeeded} - ${ballsRem}`, boxCenter, bottomY + barH * 0.71); c.fillStyle = "white"; c.font = `700 ${barH * 0.19}px 'Roboto Condensed'`; c.fillText(`RR: ${rrr}   CRR: ${crr}`, boxCenter, bottomY + barH * 0.92); c.restore(); }
            c.beginPath(); c.moveTo(bowlStart + 10, bottomY + barH/2); c.lineTo(bowlEnd - 10, bottomY + barH/2); c.strokeStyle = "rgba(255,255,255,0.4)"; c.lineWidth = 1; c.stroke(); const bowlPad = 20; const bName = match.bowler.name ? formatPlayerName(match.bowler.name) : "BOWLER"; const bFigs = `${match.bowler.wkts || 0}-${match.bowler.runs || 0} (${match.bowler.balls ? (Math.floor(match.bowler.balls/6) + '.' + (match.bowler.balls%6)) : "0.0"})`; c.textAlign = "right"; c.fillStyle = "white"; c.font = `700 ${barH * 0.30}px 'Roboto Condensed'`; c.fillText(bName, bowlEnd - bowlPad, bottomY + barH * 0.38); c.textAlign = "left"; c.fillStyle = "#cbd5e1"; c.font = `400 ${barH * 0.22}px 'Roboto'`; c.fillText(bFigs, bowlStart + bowlPad, bottomY + barH * 0.38);
            const balls = match.currentOver || []; const ballGap = 5; let ballSize = barH * 0.32; const maxBallSectionW = (ballSize + ballGap) * 6; if (balls.length > 6) { ballSize = (maxBallSectionW - (ballGap * (balls.length - 1))) / balls.length; } const ballY = bottomY + barH * 0.58; let ballX = bowlEnd - bowlPad - ballSize; const ballsToDraw = [...balls].reverse(); ballsToDraw.forEach(b => { drawBallSquare(c, b, ballX, ballY, ballSize); ballX -= (ballSize + ballGap); });
            const finalDiv = isChasing ? bowlEnd : x5; drawLogo(c, match.t2, displayImg2, xEnd - 15 - logoS, bottomY + (barH - logoS)/2, logoS, false); c.fillStyle = "white"; c.textAlign = "right"; fitText(c, formatTeamName(match.t2), xEnd - 25 - logoS, bottomY + barH * 0.45, (xEnd - finalDiv) - logoS - 35, barH * 0.35, '700', 'Roboto Condensed'); c.fillStyle = "#64748b"; c.font = `700 ${barH * 0.16}px 'Roboto'`; c.fillText("BOWLING", xEnd - 25 - logoS, bottomY + barH * 0.70);
        }

        function drawProfessionalSummary(c, w, h) {
            const cardW = w * 0.82; const cardH = h * 0.72; const x = (w - cardW) / 2; const y = (h - cardH) / 2 + (h * 0.05); const headerH = cardH * 0.18; const footerH = cardH * 0.13; const time = Date.now() * 0.0015;
            c.save(); c.shadowColor = "rgba(0,0,0,0.8)"; c.shadowBlur = 60; c.shadowOffsetY = 20; const bgGrad = c.createLinearGradient(x, y, x, y + cardH); bgGrad.addColorStop(0, "#020617"); bgGrad.addColorStop(1, "#1e1b4b"); c.fillStyle = bgGrad; drawRoundRect(c, x, y, cardW, cardH, 20); c.fill();
            const borderGrad = c.createLinearGradient(x, y, x + cardW, y + cardH); borderGrad.addColorStop(0, `hsl(${(time * 30) % 360}, 70%, 50%)`); borderGrad.addColorStop(0.5, "#22d3ee"); borderGrad.addColorStop(1, `hsl(${(time * 30 + 180) % 360}, 70%, 50%)`); c.lineWidth = 4; c.strokeStyle = borderGrad; c.stroke(); c.shadowColor = "transparent";
            const logoSize = headerH * 0.9; const logoX = x + 30; const logoY = y + (headerH - logoSize) / 2; c.save(); c.beginPath(); c.moveTo(x + 20, y); c.lineTo(x + cardW - 20, y); c.quadraticCurveTo(x + cardW, y, x + cardW, y + 20); c.lineTo(x + cardW, y + headerH); c.lineTo(x, y + headerH); c.lineTo(x, y + 20); c.quadraticCurveTo(x, y, x + 20, y); c.clip(); const hGrad = c.createLinearGradient(x, y, x, y + headerH); hGrad.addColorStop(0, "rgba(56, 189, 248, 0.2)"); hGrad.addColorStop(1, "rgba(56, 189, 248, 0.0)"); c.fillStyle = hGrad; c.fill(); c.beginPath(); c.moveTo(x, y+headerH); c.lineTo(x+cardW, y+headerH); c.strokeStyle = "rgba(255,255,255,0.15)"; c.lineWidth = 2; c.stroke(); c.restore();
            drawLogo(c, match.t1, team1Logo, logoX, logoY, logoSize, true); const textX = logoX + logoSize + 30; const maxTextW = cardW - (textX - x) - 40; c.textAlign = "left"; c.textBaseline = "alphabetic"; c.fillStyle = "white"; c.shadowColor = "rgba(0,0,0,0.8)"; c.shadowBlur = 4; c.shadowOffsetY = 2; fitText(c, (match.t1 || "TEAM NAME").toUpperCase(), textX, y + headerH * 0.55, maxTextW, cardH * 0.08, '900', 'Roboto Condensed'); c.fillStyle = "#7dd3fc"; c.font = `700 ${cardH * 0.03}px 'Roboto'`; c.shadowBlur = 0; c.shadowOffsetY = 0; const subTitle = (match.summaryType === "BOWLING") ? "BOWLING CARD" : "ICC CHAMPIONS TROPHY"; c.fillText(subTitle, textX, y + headerH * 0.85);
            const startY = y + headerH + (cardH * 0.05); c.fillStyle = "#94a3b8"; c.font = `bold ${cardH * 0.028}px 'Roboto'`; c.textAlign = "left"; let dataList = [];
            if (match.summaryType === "BOWLING") { const colX = { name: x + 40, o: x + cardW * 0.55, m: x + cardW * 0.65, r: x + cardW * 0.75, w: x + cardW * 0.85, e: x + cardW * 0.95 }; c.fillText("BOWLER", colX.name, startY); c.textAlign = "right"; c.fillText("O", colX.o, startY); c.fillText("M", colX.m, startY); c.fillText("R", colX.r, startY); c.fillText("W", colX.w, startY); c.fillText("ECON", colX.e, startY); dataList = match.bowlingCard || []; renderRows(c, dataList, startY, cardW, cardH, x, colX, "BOWLING"); } 
            else { const colX = { name: x + 40, dismissal: x + cardW * 0.45, runs: x + cardW * 0.80, balls: x + cardW * 0.95 }; c.fillText("BATTER", colX.name, startY); c.fillText("DISMISSAL", colX.dismissal, startY); c.textAlign = "right"; c.fillText("RUNS", colX.runs, startY); c.fillText("BALLS", colX.balls, startY); dataList = match.battingCard || []; renderRows(c, dataList, startY, cardW, cardH, x, colX, "BATTING"); }
            const footerY = y + cardH - footerH; c.save(); c.beginPath(); c.moveTo(x, footerY); c.lineTo(x + cardW, footerY); c.lineTo(x + cardW, y + cardH - 20); c.quadraticCurveTo(x + cardW, y + cardH, x + cardW - 20, y + cardH); c.lineTo(x + 20, y + cardH); c.quadraticCurveTo(x, y + cardH, x, y + cardH - 20); c.closePath(); c.clip(); const fGrad = c.createLinearGradient(x, footerY, x, y + cardH); fGrad.addColorStop(0, "#f1f5f9"); fGrad.addColorStop(1, "#cbd5e1"); c.fillStyle = fGrad; c.fill(); c.restore(); const fTextY = footerY + (footerH * 0.65); c.fillStyle = "#0f172a"; c.textBaseline = "alphabetic"; c.textAlign = "left"; c.font = `bold ${cardH * 0.035}px 'Roboto'`; c.fillText("EXTRAS " + (match.extras || 0), x + 40, fTextY); c.textAlign = "center"; c.fillText("OVERS " + match.overs + "." + match.balls, x + cardW/2, fTextY); c.textAlign = "right"; const scoreFont = `900 ${cardH * 0.075}px 'Roboto Condensed'`; const scoreText = match.score + "-" + match.wickets; c.font = scoreFont; const scoreWidth = c.measureText(scoreText).width; c.fillText(scoreText, x + cardW - 40, fTextY); c.font = `bold ${cardH * 0.035}px 'Roboto'`; c.fillText("TOTAL", x + cardW - 40 - scoreWidth - 20, fTextY); c.restore();
        }

        function renderRows(c, list, startY, cardW, cardH, x, colX, mode) {
            let currentY = startY + (cardH * 0.04); const rowH = cardH * 0.09; c.save(); c.beginPath(); c.rect(x, currentY, cardW, cardH * 0.55); c.clip(); 
            list.forEach((p, i) => {
                const rowY = currentY; const textY = rowY + (rowH * 0.65); let isActive = false; if (mode === "BATTING" && p.status.includes("NOT OUT")) isActive = true;
                if (isActive) { const activeGrad = c.createLinearGradient(x, rowY, x + cardW, rowY); activeGrad.addColorStop(0, "#0ea5e9"); activeGrad.addColorStop(1, "#0284c7"); c.fillStyle = activeGrad; } else { c.fillStyle = (i % 2 === 0) ? "rgba(255,255,255,0.05)" : "transparent"; } c.fillRect(x, rowY, cardW, rowH);
                c.fillStyle = isActive ? "white" : (mode === "BATTING" && !isActive ? "#94a3b8" : "white"); c.textAlign = "left"; c.font = `700 ${cardH * 0.045}px 'Roboto Condensed'`; c.fillText(p.name.toUpperCase(), colX.name, textY);
                if (mode === "BOWLING") { c.textAlign = "right"; c.font = `500 ${cardH * 0.045}px 'Roboto'`; c.fillText(p.o, colX.o, textY); c.fillText(p.m, colX.m, textY); c.fillText(p.r, colX.r, textY); c.font = `900 ${cardH * 0.05}px 'Roboto'`; c.fillText(p.w, colX.w, textY); c.font = `500 ${cardH * 0.045}px 'Roboto'`; c.fillText(p.e, colX.e, textY); } 
                else { c.font = `500 ${cardH * 0.03}px 'Roboto'`; if (isActive) { c.fillStyle = "rgba(255,255,255,0.9)"; c.fillText("NOT OUT", colX.dismissal, textY); } else { c.fillStyle = "#94a3b8"; c.fillText(p.status.toLowerCase(), colX.dismissal, textY); } c.textAlign = "right"; c.font = `900 ${cardH * 0.055}px 'Roboto'`; c.fillStyle = "white"; c.fillText(p.runs, colX.runs, textY); c.font = `500 ${cardH * 0.035}px 'Roboto'`; c.fillStyle = isActive ? "white" : "#94a3b8"; c.fillText(p.balls, colX.balls, textY); } currentY += rowH;
            }); c.restore();
        }

        function drawDismissalCard(c, w, h) {
            const d = match.dismissalData; if(!d) return; const cardW = w * 0.85; const cardH = h * 0.22; const x = (w - cardW) / 2; const y = h - cardH - (h * 0.1);
            c.save(); c.shadowColor = "rgba(0,0,0,0.8)"; c.shadowBlur = 30; c.shadowOffsetY = 15; const bgGrad = c.createLinearGradient(x, y, x + cardW, y); bgGrad.addColorStop(0, "#000000"); bgGrad.addColorStop(0.2, "#001233"); bgGrad.addColorStop(0.8, "#001233"); bgGrad.addColorStop(1, "#000000"); c.fillStyle = bgGrad; drawRoundRect(c, x, y, cardW, cardH, 20); c.fill(); c.shadowColor = "transparent";
            const logoSize = cardH * 0.85; const logoX = x + 40; const logoY = y + (cardH - logoSize) / 2; c.fillStyle = "white"; c.beginPath(); c.arc(logoX + logoSize/2, logoY + logoSize/2, logoSize/2, 0, Math.PI*2); c.fill(); c.fillStyle = "#e2e8f0"; c.beginPath(); c.arc(logoX + logoSize/2, logoY + logoSize/2, logoSize/2 - 4, 0, Math.PI*2); c.fill(); drawLogo(c, "TM", team1Logo, logoX + 4, logoY + 4, logoSize - 8, true);
            const nameParts = d.name.split(" "); let firstName = ""; let lastName = d.name; if(nameParts.length > 1) { lastName = nameParts.pop(); firstName = nameParts.join(" "); } const textX = logoX + logoSize + 40; const nameY = y + (cardH * 0.45); c.textAlign = "left"; c.textBaseline = "alphabetic"; c.fillStyle = "white"; c.font = `400 ${cardH * 0.35}px 'Roboto'`; c.fillText(firstName.toUpperCase(), textX, nameY); const firstW = c.measureText(firstName.toUpperCase() + " ").width; c.font = `900 ${cardH * 0.35}px 'Roboto'`; c.fillText(lastName.toUpperCase(), textX + (firstName ? firstW : 0), nameY); c.fillStyle = "#94a3b8"; c.font = `500 ${cardH * 0.15}px 'Roboto'`; c.fillText(d.howOut, textX, y + (cardH * 0.7));
            const boxH = cardH * 0.7; const boxW = boxH * 1.8; const boxX = x + cardW - boxW - 30; const boxY = y + (cardH - boxH) / 2; c.save(); const boxGrad = c.createLinearGradient(boxX, boxY, boxX, boxY + boxH); boxGrad.addColorStop(0, "#3b82f6"); boxGrad.addColorStop(1, "#0f172a"); c.fillStyle = boxGrad; c.strokeStyle = "#cbd5e1"; c.lineWidth = 4; drawRoundRect(c, boxX, boxY, boxW, boxH, 15); c.fill(); c.stroke(); c.fillStyle = "white"; c.textAlign = "center"; c.font = `900 ${boxH * 0.6}px 'Anton'`; c.fillText(d.score, boxX + boxW/2, boxY + boxH * 0.55); c.font = `500 ${boxH * 0.2}px 'Roboto'`; c.fillText(`OFF ${d.balls}`, boxX + boxW/2, boxY + boxH * 0.85); c.restore(); c.restore();
        }
    </script>
</body>
</html>
